{"name":"mquery","tagline":"Expressive MongoDB query builder","body":"`mquery` is a fluent mongodb query builder designed to run in multiple environments. As of v0.1, `mquery` runs on `Node.js` only with support for the MongoDB shell and browser environments planned for upcoming releases.\r\n\r\n##Features\r\n\r\n  - fluent query builder api\r\n  - custom base query support\r\n  - MongoDB 2.4 geoJSON support\r\n  - method + option combinations validation\r\n  - node.js driver compatibility\r\n  - environment detection\r\n  - [debug](https://github.com/visionmedia/debug) support\r\n  - separated collection implementations for maximum flexibility\r\n\r\n##Use\r\n\r\n```js\r\nrequire('mongodb').connect(uri, function (err, db) {\r\n  if (err) return handleError(err);\r\n\r\n  // get a collection\r\n  var collection = db.collection('artists');\r\n\r\n  // pass it to the constructor\r\n  mquery(collection).find({..}, callback);\r\n\r\n  // or pass it to the collection method\r\n  mquery().find({..}).collection(collection).exec(callback)\r\n\r\n  // or better yet, create a custom query constructor that has it always set\r\n  var Artist = mquery(collection).toConstructor();\r\n  Artist().find(..).where(..).exec(callback)\r\n})\r\n```\r\n\r\n`mquery` requires a collection object to work with. In the example above we just pass the collection object created using the official [MongoDB driver](https://github.com/mongodb/node-mongodb-native).\r\n\r\n\r\n##Fluent API\r\n\r\n###find()\r\n\r\nDeclares this query a _find_ query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.\r\n\r\n```js\r\nmquery().find()\r\nmquery().find(match)\r\nmquery().find(callback)\r\nmquery().find(match, function (err, docs) {\r\n  assert(Array.isArray(docs));\r\n})\r\n```\r\n\r\n###findOne()\r\n\r\nDeclares this query a _findOne_ query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.\r\n\r\n```js\r\nmquery().findOne()\r\nmquery().findOne(match)\r\nmquery().findOne(callback)\r\nmquery().findOne(match, function (err, doc) {\r\n  if (doc) {\r\n    // the document may not be found\r\n    console.log(doc);\r\n  }\r\n})\r\n```\r\n\r\n###count()\r\n\r\nDeclares this query a _count_ query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.\r\n\r\n```js\r\nmquery().count()\r\nmquery().count(match)\r\nmquery().count(callback)\r\nmquery().count(match, function (err, number){\r\n  console.log('we found %d matching documents', number);\r\n})\r\n```\r\n\r\n###remove()\r\n\r\nDeclares this query a _remove_ query. Optionally pass a match clause and / or callback. If a callback is passed the query is executed.\r\n\r\n```js\r\nmquery().remove()\r\nmquery().remove(match)\r\nmquery().remove(callback)\r\nmquery().remove(match, function (err){})\r\n```\r\n\r\n###update()\r\n\r\nDeclares this query an _update_ query. Optionally pass an update document, match clause, options or callback. If a callback is passed, the query is executed. To force execution without passing a callback, run `update(true)`.\r\n\r\n```js\r\nmquery().update()\r\nmquery().update(match, updateDocument)\r\nmquery().update(match, updateDocument, options)\r\n\r\n// the following all execute the command\r\nmquery().update(callback)\r\nmquery().update({$set: updateDocument, callback)\r\nmquery().update(match, updateDocument, callback)\r\nmquery().update(match, updateDocument, options, function (err, result){})\r\nmquery().update(true) // executes (unsafe write)\r\n```\r\n\r\n#####the update document\r\n\r\nAll paths passed that are not `$atomic` operations will become `$set` ops. For example:\r\n\r\n```js\r\nmquery(collection).where({ _id: id }).update({ title: 'words' }, callback)\r\n```\r\n\r\nbecomes\r\n\r\n```js\r\ncollection.update({ _id: id }, { $set: { title: 'words' }}, callback)\r\n```\r\n\r\nThis behavior can be overridden using the `overwrite` option (see below).\r\n\r\n#####options\r\n\r\nOptions are passed to the `setOptions()` method.\r\n\r\n- overwrite\r\n\r\nPassing an empty object `{ }` as the update document will result in a no-op unless the `overwrite` option is passed. Without the `overwrite` option, the update operation will be ignored and the callback executed without sending the command to MongoDB to prevent accidently overwritting documents in the collection.\r\n\r\n```js\r\nvar q = mquery(collection).where({ _id: id }).setOptions({ overwrite: true });\r\nq.update({ }, callback); // overwrite with an empty doc\r\n```\r\n\r\nThe `overwrite` option isn't just for empty objects, it also provides a means to override the default `$set` conversion and send the update document as is.\r\n\r\n```js\r\n// create a base query\r\nvar base = mquery({ _id: 108 }).collection(collection).toConstructor();\r\n\r\nbase().findOne(function (err, doc) {\r\n  console.log(doc); // { _id: 108, name: 'cajon' })\r\n\r\n  base().setOptions({ overwrite: true }).update({ changed: true }, function (err) {\r\n    base.findOne(function (err, doc) {\r\n      console.log(doc); // { _id: 108, changed: true }) - the doc was overwritten\r\n    });\r\n  });\r\n})\r\n```\r\n\r\n- multi\r\n\r\nUpdates only modify a single document by default. To update multiple documents, set the `multi` option to `true`.\r\n\r\n```js\r\nmquery()\r\n  .collection(coll)\r\n  .update({ name: /^match/ }, { $addToSet: { arr: 4 }}, { multi: true }, callback)\r\n\r\n// another way of doing it\r\nmquery({ name: /^match/ })\r\n  .collection(coll)\r\n  .setOptions({ multi: true })\r\n  .update({ $addToSet: { arr: 4 }}, callback)\r\n\r\n// update multiple documents with an empty doc\r\nvar q = mquery(collection).where({ name: /^match/ });\r\nq.setOptions({ multi: true, overwrite: true })\r\nq.update({ });\r\nq.update(function (err, result) {\r\n  console.log(arguments);\r\n});\r\n```\r\n\r\n###findOneAndUpdate()\r\n\r\nDeclares this query a _findAndModify_ with update query. Optionally pass a match clause, update document, options, or callback. If a callback is passed, the query is executed.\r\n\r\nWhen executed, the first matching document (if found) is modified according to the update document and passed back to the callback.\r\n\r\n#####options\r\n\r\nOptions are passed to the `setOptions()` method.\r\n\r\n- `new`: boolean - true to return the modified document rather than the original. defaults to true\r\n- `upsert`: boolean - creates the object if it doesn't exist. defaults to false\r\n- `sort`: if multiple docs are found by the match condition, sets the sort order to choose which doc to update\r\n\r\n```js\r\nquery.findOneAndUpdate()\r\nquery.findOneAndUpdate(updateDocument)\r\nquery.findOneAndUpdate(match, updateDocument)\r\nquery.findOneAndUpdate(match, updateDocument, options)\r\n\r\n// the following all execute the command\r\nquery.findOneAndUpdate(callback)\r\nquery.findOneAndUpdate(updateDocument, callback)\r\nquery.findOneAndUpdate(match, updateDocument, callback)\r\nquery.findOneAndUpdate(match, updateDocument, options, function (err, doc) {\r\n  if (doc) {\r\n    // the document may not be found\r\n    console.log(doc);\r\n  }\r\n})\r\n ```\r\n\r\n###findOneAndRemove()\r\n\r\nDeclares this query a _findAndModify_ with remove query. Optionally pass a match clause, options, or callback. If a callback is passed, the query is executed.\r\n\r\nWhen executed, the first matching document (if found) is modified according to the update document, removed from the collection and passed to the callback.\r\n\r\n#####options\r\n\r\nOptions are passed to the `setOptions()` method.\r\n\r\n- `sort`: if multiple docs are found by the condition, sets the sort order to choose which doc to modify and remove\r\n\r\n```js\r\nA.where().findOneAndRemove()\r\nA.where().findOneAndRemove(match)\r\nA.where().findOneAndRemove(match, options)\r\n\r\n// the following all execute the command\r\nA.where().findOneAndRemove(callback)\r\nA.where().findOneAndRemove(match, callback)\r\nA.where().findOneAndRemove(match, options, function (err, doc) {\r\n  if (doc) {\r\n    // the document may not be found\r\n    console.log(doc);\r\n  }\r\n})\r\n ```\r\n\r\n###distinct()\r\n\r\nDeclares this query a _distinct_ query. Optionally pass the distinct field, a match clause or callback. If a callback is passed the query is executed.\r\n\r\n```js\r\nmquery().distinct()\r\nmquery().distinct(match)\r\nmquery().distinct(match, field)\r\nmquery().distinct(field)\r\n\r\n// the following all execute the command\r\nmquery().distinct(callback)\r\nmquery().distinct(field, callback)\r\nmquery().distinct(match, callback)\r\nmquery().distinct(match, field, function (err, result) {\r\n  console.log(result);\r\n})\r\n```\r\n\r\n###exec()\r\n\r\nExecutes the query.\r\n\r\n```js\r\nmquery().findOne().where('route').intersects(polygon).exec(function (err, docs){})\r\n```\r\n\r\n-------------\r\n\r\n###all()\r\n\r\nSpecifies an `$all` query condition\r\n\r\n```js\r\nmquery().where('permission').all(['read', 'write'])\r\n```\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/all/)\r\n\r\n###and()\r\n\r\nSpecifies arguments for an `$and` condition\r\n\r\n```js\r\nmquery().and([{ color: 'green' }, { status: 'ok' }])\r\n```\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/and/)\r\n\r\n###box()\r\n\r\nSpecifies a `$box` condition\r\n\r\n```js\r\nvar lowerLeft = [40.73083, -73.99756]\r\nvar upperRight= [40.741404,  -73.988135]\r\n\r\nmquery().where('location').within().box(lowerLeft, upperRight)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/box/)\r\n\r\n###circle()\r\n\r\nSpecifies a `$center` or `$centerSphere` condition.\r\n\r\n```js\r\nvar area = { center: [50, 50], radius: 10, unique: true }\r\nquery.where('loc').within().circle(area)\r\nquery.center('loc', area);\r\n\r\n// for spherical calculations\r\nvar area = { center: [50, 50], radius: 10, unique: true, spherical: true }\r\nquery.where('loc').within().circle(area)\r\nquery.center('loc', area);\r\n```\r\n\r\n- [MongoDB Documentation - center](http://docs.mongodb.org/manual/reference/operator/center/)\r\n- [MongoDB Documentation - centerSphere](http://docs.mongodb.org/manual/reference/operator/centerSphere/)\r\n\r\n###elemMatch()\r\n\r\nSpecifies an `$elemMatch` condition\r\n\r\n```js\r\nquery.where('comment').elemMatch({ author: 'autobot', votes: {$gte: 5}})\r\n\r\nquery.elemMatch('comment', function (elem) {\r\n  elem.where('author').equals('autobot');\r\n  elem.where('votes').gte(5);\r\n})\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/elemMatch/)\r\n\r\n###equals()\r\n\r\nSpecifies the complementary comparison value for the path specified with `where()`.\r\n\r\n```js\r\nmquery().where('age').equals(49);\r\n\r\n// is the same as\r\n\r\nmquery().where({ 'age': 49 });\r\n```\r\n\r\n###exists()\r\n\r\nSpecifies an `$exists` condition\r\n\r\n```js\r\n// { name: { $exists: true }}\r\nmquery().where('name').exists()\r\nmquery().where('name').exists(true)\r\nmquery().exists('name')\r\n\r\n// { name: { $exists: false }}\r\nmquery().where('name').exists(false);\r\nmquery().exists('name', false);\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/exists/)\r\n\r\n###geometry()\r\n\r\nSpecifies a `$geometry` condition\r\n\r\n```js\r\nvar polyA = [[[ 10, 20 ], [ 10, 40 ], [ 30, 40 ], [ 30, 20 ]]]\r\nquery.where('loc').within().geometry({ type: 'Polygon', coordinates: polyA })\r\n\r\n// or\r\nvar polyB = [[ 0, 0 ], [ 1, 1 ]]\r\nquery.where('loc').within().geometry({ type: 'LineString', coordinates: polyB })\r\n\r\n// or\r\nvar polyC = [ 0, 0 ]\r\nquery.where('loc').within().geometry({ type: 'Point', coordinates: polyC })\r\n\r\n// or\r\nquery.where('loc').intersects().geometry({ type: 'Point', coordinates: polyC })\r\n```\r\n\r\n`geometry()` **must** come after either `intersects()` or `within()`.\r\n\r\nThe `object` argument must contain `type` and `coordinates` properties.\r\n\r\n- type `String`\r\n- coordinates `Array`\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/geometry/)\r\n\r\n###gt()\r\n\r\nSpecifies a `$gt` query condition.\r\n\r\n```js\r\nmquery().where('clicks').gt(999)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/gt/)\r\n\r\n###gte()\r\n\r\nSpecifies a `$gte` query condition.\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/gte/)\r\n\r\n```js\r\nmquery().where('clicks').gte(1000)\r\n```\r\n\r\n###in()\r\n\r\nSpecifies an `$in` query condition.\r\n\r\n```js\r\nmquery().where('author_id').in([3, 48901, 761])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/in/)\r\n\r\n###intersects()\r\n\r\nDeclares an `$geoIntersects` query for `geometry()`.\r\n\r\n```js\r\nquery.where('path').intersects().geometry({\r\n    type: 'LineString'\r\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\r\n})\r\n\r\n// geometry arguments are supported\r\nquery.where('path').intersects({\r\n    type: 'LineString'\r\n  , coordinates: [[180.0, 11.0], [180, 9.0]]\r\n})\r\n```\r\n\r\n**Must** be used after `where()`.\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/geoIntersects/)\r\n\r\n###lt()\r\n\r\nSpecifies a `$lt` query condition.\r\n\r\n```js\r\nmquery().where('clicks').lt(50)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/lt/)\r\n\r\n###lte()\r\n\r\nSpecifies a `$lte` query condition.\r\n\r\n```js\r\nmquery().where('clicks').lte(49)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/lte/)\r\n\r\n###maxDistance()\r\n\r\nSpecifies a `$maxDistance` query condition.\r\n\r\n```js\r\nmquery().where('location').near({ center: [139, 74.3] }).maxDistance(5)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/maxDistance/)\r\n\r\n###mod()\r\n\r\nSpecifies a `$mod` condition\r\n\r\n```js\r\nmquery().where('count').mod(2, 0)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/mod/)\r\n\r\n###ne()\r\n\r\nSpecifies a `$ne` query condition.\r\n\r\n```js\r\nmquery().where('status').ne('ok')\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/ne/)\r\n\r\n###nin()\r\n\r\nSpecifies an `$nin` query condition.\r\n\r\n```js\r\nmquery().where('author_id').nin([3, 48901, 761])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/nin/)\r\n\r\n###nor()\r\n\r\nSpecifies arguments for an `$nor` condition.\r\n\r\n```js\r\nmquery().nor([{ color: 'green' }, { status: 'ok' }])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/nor/)\r\n\r\n###or()\r\n\r\nSpecifies arguments for an `$or` condition.\r\n\r\n```js\r\nmquery().or([{ color: 'red' }, { status: 'emergency' }])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/or/)\r\n\r\n###polygon()\r\n\r\nSpecifies a `$polygon` condition\r\n\r\n```js\r\nmquery().where('loc').within().polygon([10,20], [13, 25], [7,15])\r\nmquery().polygon('loc', [10,20], [13, 25], [7,15])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/polygon/)\r\n\r\n###regex()\r\n\r\nSpecifies a `$regex` query condition.\r\n\r\n```js\r\nmquery().where('name').regex(/^sixstepsrecords/)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/regex/)\r\n\r\n###select()\r\n\r\nSpecifies which document fields to include or exclude\r\n\r\n```js\r\n// 1 means include, 0 means exclude\r\nmquery().select({ name: 1, address: 1, _id: 0 })\r\n\r\n// or\r\n\r\nmquery().select('name address -_id')\r\n```\r\n\r\n#####String syntax\r\n\r\nWhen passing a string, prefixing a path with `-` will flag that path as excluded. When a path does not have the `-` prefix, it is included.\r\n\r\n```js\r\n// include a and b, exclude c\r\nquery.select('a b -c');\r\n\r\n// or you may use object notation, useful when\r\n// you have keys already prefixed with a \"-\"\r\nquery.select({a: 1, b: 1, c: 0});\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n###size()\r\n\r\nSpecifies a `$size` query condition.\r\n\r\n```js\r\nmquery().where('someArray').size(6)\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/size/)\r\n\r\n###slice()\r\n\r\nSpecifies a `$slice` projection for a `path`\r\n\r\n```js\r\nmquery().where('comments').slice(5)\r\nmquery().where('comments').slice(-5)\r\nmquery().where('comments').slice([-10, 5])\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/projection/slice/)\r\n\r\n###within()\r\n\r\nSets a `$within` argument for geo-spatial queries\r\n\r\n```js\r\nmquery().within().box()\r\nmquery().within().circle()\r\nmquery().within().geometry()\r\n\r\nmquery().where('loc').within({ center: [50,50], radius: 10, unique: true, spherical: true });\r\nmquery().where('loc').within({ box: [[40.73, -73.9], [40.7, -73.988]] });\r\nmquery().where('loc').within({ polygon: [[],[],[],[]] });\r\n\r\nmquery().where('loc').within([], [], []) // polygon\r\nmquery().where('loc').within([], []) // box\r\nmquery().where('loc').within({ type: 'LineString', coordinates: [...] }); // geometry\r\n```\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/reference/operator/geoWithin/)\r\n\r\n###where()\r\n\r\nSpecifies a `path` for use with chaining\r\n\r\n```js\r\n// instead of writing:\r\nmquery().find({age: {$gte: 21, $lte: 65}});\r\n\r\n// we can instead write:\r\nmquery().where('age').gte(21).lte(65);\r\n\r\n// passing query conditions is permitted too\r\nmquery().find().where({ name: 'vonderful' })\r\n\r\n// chaining\r\nmquery()\r\n.where('age').gte(21).lte(65)\r\n.where({ 'name': /^vonderful/i })\r\n.where('friends').slice(10)\r\n.exec(callback)\r\n```\r\n\r\n###$where()\r\n\r\nSpecifies a `$where` condition.\r\n\r\nUse `$where` when you need to select documents using a JavaScript expression.\r\n\r\n```js\r\nquery.$where('this.comments.length > 10 || this.name.length > 5').exec(callback)\r\n\r\nquery.$where(function () {\r\n  return this.comments.length > 10 || this.name.length > 5;\r\n})\r\n```\r\n\r\nOnly use `$where` when you have a condition that cannot be met using other MongoDB operators like `$lt`. Be sure to read about all of [its caveats](http://docs.mongodb.org/manual/reference/operator/where/) before using.\r\n\r\n-----------\r\n\r\n###batchSize()\r\n\r\nSpecifies the batchSize option.\r\n\r\n```js\r\nquery.batchSize(100)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/method/cursor.batchSize/)\r\n\r\n###comment()\r\n\r\nSpecifies the comment option.\r\n\r\n```js\r\nquery.comment('login query');\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/)\r\n\r\n###hint()\r\n\r\nSets query hints.\r\n\r\n```js\r\nmquery().hint({ indexA: 1, indexB: -1 })\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/hint/)\r\n\r\n###limit()\r\n\r\nSpecifies the limit option.\r\n\r\n```js\r\nquery.limit(20)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/method/cursor.limit/)\r\n\r\n###maxScan()\r\n\r\nSpecifies the maxScan option.\r\n\r\n```js\r\nquery.maxScan(100)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/maxScan/)\r\n\r\n###skip()\r\n\r\nSpecifies the skip option.\r\n\r\n```js\r\nquery.skip(100).limit(20)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/method/cursor.skip/)\r\n\r\n###sort()\r\n\r\nSets the query sort order.\r\n\r\nIf an object is passed, key values allowed are `asc`, `desc`, `ascending`, `descending`, `1`, and `-1`.\r\n\r\nIf a string is passed, it must be a space delimited list of path names. The sort order of each path is ascending unless the path name is prefixed with `-` which will be treated as descending.\r\n\r\n```js\r\n// these are equivalent\r\nquery.sort({ field: 'asc', test: -1 });\r\nquery.sort('field -test');\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/method/cursor.sort/)\r\n\r\n###read()\r\n\r\nSets the readPreference option for the query.\r\n\r\n```js\r\nmquery().read('primary')\r\nmquery().read('p')  // same as primary\r\n\r\nmquery().read('primaryPreferred')\r\nmquery().read('pp') // same as primaryPreferred\r\n\r\nmquery().read('secondary')\r\nmquery().read('s')  // same as secondary\r\n\r\nmquery().read('secondaryPreferred')\r\nmquery().read('sp') // same as secondaryPreferred\r\n\r\nmquery().read('nearest')\r\nmquery().read('n')  // same as nearest\r\n\r\n// specifying tags\r\nmquery().read('s', [{ dc:'sf', s: 1 },{ dc:'ma', s: 2 }])\r\n```\r\n\r\n#####Preferences:\r\n\r\n- `primary` - (default) Read from primary only. Operations will produce an error if primary is unavailable. Cannot be combined with tags.\r\n- `secondary` - Read from secondary if available, otherwise error.\r\n- `primaryPreferred` - Read from primary if available, otherwise a secondary.\r\n- `secondaryPreferred` - Read from a secondary if available, otherwise read from the primary.\r\n- `nearest` - All operations read from among the nearest candidates, but unlike other modes, this option will include both the primary and all secondaries in the random selection.\r\n\r\nAliases\r\n\r\n- `p`   primary\r\n- `pp`  primaryPreferred\r\n- `s`   secondary\r\n- `sp`  secondaryPreferred\r\n- `n`   nearest\r\n\r\nRead more about how to use read preferrences [here](http://docs.mongodb.org/manual/applications/replication/#read-preference) and [here](http://mongodb.github.com/node-mongodb-native/driver-articles/anintroductionto1_1and2_2.html#read-preferences).\r\n\r\n###slaveOk()\r\n\r\nSets the slaveOk option. `true` allows reading from secondaries.\r\n\r\n**deprecated** use [read()](#read) preferences instead if on mongodb >= 2.2\r\n\r\n```js\r\nquery.slaveOk() // true\r\nquery.slaveOk(true)\r\nquery.slaveOk(false)\r\n```\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/method/rs.slaveOk/)\r\n\r\n###snapshot()\r\n\r\nSpecifies this query as a snapshot query.\r\n\r\n```js\r\nmquery().snapshot() // true\r\nmquery().snapshot(true)\r\nmquery().snapshot(false)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB documentation](http://docs.mongodb.org/manual/reference/operator/snapshot/)\r\n\r\n###tailable()\r\n\r\nSets tailable option.\r\n\r\n```js\r\nmquery().tailable() <== true\r\nmquery().tailable(true)\r\nmquery().tailable(false)\r\n```\r\n\r\n_Cannot be used with `distinct()`._\r\n\r\n[MongoDB Documentation](http://docs.mongodb.org/manual/tutorial/create-tailable-cursor/)\r\n\r\n##Helpers\r\n\r\n###collection()\r\n\r\nSets the querys collection.\r\n\r\n```js\r\nmquery().collection(aCollection)\r\n```\r\n\r\n\r\n###merge(object)\r\n\r\nMerges other mquery or match condition objects into this one. When an muery instance is passed, its match conditions, field selection and options are merged.\r\n\r\n```js\r\nvar drum = mquery({ type: 'drum' }).collection(instruments);\r\nvar redDrum = mqery({ color: 'red' }).merge(drum);\r\nredDrum.count(function (err, n) {\r\n  console.log('there are %d red drums', n);\r\n})\r\n```\r\n\r\nInternally uses `Query.canMerge` to determine validity.\r\n\r\n###setOptions(options)\r\n\r\nSets query options.\r\n\r\n```js\r\nmquery().setOptions({ collection: coll, limit: 20 })\r\n```\r\n\r\n#####options\r\n\r\n- [tailable](#tailable) *\r\n- [sort](#sort) *\r\n- [limit](#limit) *\r\n- [skip](#skip) *\r\n- [maxScan](#maxScan) *\r\n- [batchSize](#batchSize) *\r\n- [comment](#comment) *\r\n- [snapshot](#snapshot) *\r\n- [hint](#hint) *\r\n- [slaveOk](#slaveOk) *\r\n- [safe](http://docs.mongodb.org/manual/reference/write-concern/): Boolean - passed through to the collection. Setting to `true` is equivalent to `{ w: 1 }`\r\n- [collection](#collection): the collection to query against\r\n\r\n_* denotes a query helper method is also available_\r\n\r\n###Query.canMerge(conditions)\r\n\r\nDetermines if `conditions` can be merged using `mquery().merge()`.\r\n\r\n```js\r\nvar query = mquery({ type: 'drum' });\r\nvar okToMerge = mquery.canMerge(anObject)\r\nif (okToMerge) {\r\n  query.merge(anObject);\r\n}\r\n```\r\n\r\n##Custom Base Queries\r\n\r\nOften times we want custom base queries that encapsulate predefined criteria. With `mquery` this is easy. First create the query you want to reuse and call its `toConstructor()` method which returns a new subclass of `mquery` that retains all options and criteria of the original.\r\n\r\n```js\r\nvar greatMovies = mquery(movieCollection).where('rating').gte(4.5).toConstructor();\r\n\r\n// use it!\r\ngreatMovies().count(function (err, n) {\r\n  console.log('There are %d great movies', n);\r\n});\r\n\r\ngreatMovies().where({ name: /^Life/ }).select('name').find(function (err, docs) {\r\n  console.log(docs);\r\n});\r\n```\r\n\r\n##Validation\r\n\r\nMethod and options combinations are checked for validity at runtime to prevent creation of invalid query constructs. For example, a `distinct` query does not support specifying options like `hint` or field selection. In this case an error will be thrown so you can catch these mistakes in development.\r\n\r\n##Debug support\r\n\r\nDebug mode is provided through the use of the [debug](https://github.com/visionmedia/debug) module. To enable:\r\n\r\n    DEBUG=mquery node yourprogram.js\r\n\r\nRead the debug module documentation for more details.\r\n\r\n##Future goals\r\n\r\n  - mongo shell compatibility\r\n  - browser compatibility\r\n  - mongoose compatibility\r\n\r\n## Installation\r\n\r\n    $ npm install mquery\r\n\r\n## License\r\n\r\n[MIT](https://github.com/aheckmann/mquery/blob/master/LICENSE)\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}